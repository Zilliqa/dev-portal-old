(window.webpackJsonp=window.webpackJsonp||[]).push([[19],{118:function(e,t,r){"use strict";r.r(t),r.d(t,"frontMatter",(function(){return a})),r.d(t,"metadata",(function(){return s})),r.d(t,"rightToc",(function(){return c})),r.d(t,"default",(function(){return d}));var n=r(2),o=r(6),i=(r(0),r(296)),a={id:"core-multipliers",title:"Multipliers",keywords:["core","multipliers"],description:"Core protocol design - multipliers."},s={id:"contributors/core-multipliers",isDocsHomePage:!1,title:"Multipliers",description:"Core protocol design - multipliers.",source:"@site/docs/contributors/core-multipliers.md",permalink:"/docs/contributors/core-multipliers",editUrl:"https://github.com/Zilliqa/dev-portal/tree/master/docs/contributors/core-multipliers.md",sidebar:"ContributorsSidebar",previous:{title:"Transaction Dispatch",permalink:"/docs/contributors/core-transaction-dispatch"},next:{title:"PoW Algorithm",permalink:"/docs/contributors/core-pow"}},c=[],l={rightToc:c};function d(e){var t=e.components,r=Object(o.a)(e,["components"]);return Object(i.b)("wrapper",Object(n.a)({},l,r,{components:t,mdxType:"MDXLayout"}),Object(i.b)("hr",null),Object(i.b)("p",null,"The Zilliqa network - specifically, the DS committee and shard nodes - maintain a list of lookup nodes. All blockchain data generated by the network are forwarded to these lookup nodes, in order for them to function as ",Object(i.b)("a",Object(n.a)({parentName:"p"},{href:"../basics/basics-zil-nodes#lookup-nodes"}),"full nodes"),"."),Object(i.b)("p",null,"On the other hand, the network has no direct knowledge of all existing ",Object(i.b)("a",Object(n.a)({parentName:"p"},{href:"../basics/basics-zil-nodes#seed-nodes"}),"seed nodes"),". Seed nodes, which are also full nodes, need to receive the same data as the lookup nodes to remain synced with the network. Among these seed nodes are the ones maintained by Zilliqa Research to service the public API, as well as the ones hosted by exchanges and ecosystem partners."),Object(i.b)("p",null,"To address this communication gap, multipliers play the role of receiving blockchain data-related messages from the network and forwarding them to seed nodes. In addition to the aforementioned lookup nodes, the network also maintains a list of these multiplier nodes, hence blockchain data is also sent to them. The Zilliqa Mainnet runs with several multipliers, each one configured to forward messages to a list of seed nodes identified by their IP address and port."),Object(i.b)("p",null,"The multiplier is a simple Go program that basically listens at a particular port for incoming messages and forwards the messages to the forwarding list. It periodically checks this list for any updates, enabling the addition or removal of seed nodes anytime. The multiplier uses hashes to prevent duplicate messsages from being forwarded repeatedly. It is robust enough to retry sending messages to recipients in the event of I/O timeout errors, which could happen due to network glitches on either end."))}d.isMDXComponent=!0},296:function(e,t,r){"use strict";r.d(t,"a",(function(){return p})),r.d(t,"b",(function(){return f}));var n=r(0),o=r.n(n);function i(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function a(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function s(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?a(Object(r),!0).forEach((function(t){i(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):a(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function c(e,t){if(null==e)return{};var r,n,o=function(e,t){if(null==e)return{};var r,n,o={},i=Object.keys(e);for(n=0;n<i.length;n++)r=i[n],t.indexOf(r)>=0||(o[r]=e[r]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)r=i[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(o[r]=e[r])}return o}var l=o.a.createContext({}),d=function(e){var t=o.a.useContext(l),r=t;return e&&(r="function"==typeof e?e(t):s(s({},t),e)),r},p=function(e){var t=d(e.components);return o.a.createElement(l.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return o.a.createElement(o.a.Fragment,{},t)}},m=o.a.forwardRef((function(e,t){var r=e.components,n=e.mdxType,i=e.originalType,a=e.parentName,l=c(e,["components","mdxType","originalType","parentName"]),p=d(r),m=n,f=p["".concat(a,".").concat(m)]||p[m]||u[m]||i;return r?o.a.createElement(f,s(s({ref:t},l),{},{components:r})):o.a.createElement(f,s({ref:t},l))}));function f(e,t){var r=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var i=r.length,a=new Array(i);a[0]=m;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s.mdxType="string"==typeof e?e:n,a[1]=s;for(var l=2;l<i;l++)a[l]=r[l];return o.a.createElement.apply(null,a)}return o.a.createElement.apply(null,r)}m.displayName="MDXCreateElement"}}]);