(window.webpackJsonp=window.webpackJsonp||[]).push([[66],{170:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return s})),n.d(t,"metadata",(function(){return i})),n.d(t,"rightToc",(function(){return c})),n.d(t,"default",(function(){return l}));var r=n(2),o=n(6),a=(n(0),n(280)),s={id:"core-message-queues",title:"Message Queues and Jobs",keywords:["core","message","queues","jobs"],description:"Core protocol design - message queues and jobs."},i={id:"contributors/core-message-queues",isDocsHomePage:!1,title:"Message Queues and Jobs",description:"Core protocol design - message queues and jobs.",source:"@site/docs/contributors/core-message-queues.md",permalink:"/docs/contributors/core-message-queues",editUrl:"https://github.com/Zilliqa/dev-portal/tree/master/docs/contributors/core-message-queues.md",sidebar:"ContributorsSidebar",previous:{title:"Message Dispatch and Processing",permalink:"/docs/contributors/core-message-dispatch"},next:{title:"Incremental DB",permalink:"/docs/contributors/core-incremental-db"}},c=[],u={rightToc:c};function l(e){var t=e.components,n=Object(o.a)(e,["components"]);return Object(a.b)("wrapper",Object(r.a)({},u,n,{components:t,mdxType:"MDXLayout"}),Object(a.b)("hr",null),Object(a.b)("p",null,"Incoming and outgoing message queues are maintained between ",Object(a.b)("inlineCode",{parentName:"p"},"P2PComm")," and the rest of the Zilliqa core. This helps provide some ordering in the processing of messages, and it also adds some control over the number of messages that can be buffered. Once ready for processing, messages enter a thread pool, which regulates the number of messages that can be processed concurrently."),Object(a.b)("p",null,"After an incoming message is read from a socket, it is first inserted into ",Object(a.b)("inlineCode",{parentName:"p"},"Zilliqa::m_msgQueue"),", whose maximum size is controlled by ",Object(a.b)("inlineCode",{parentName:"p"},"MSGQUEUE_SIZE"),". When the queue reaches full capacity, any further incoming messages are dropped. A dedicated thread launched during startup manages dequeueing of messages and sending them to ",Object(a.b)("inlineCode",{parentName:"p"},"Zilliqa::m_queuePool"),", a thread pool limited by ",Object(a.b)("inlineCode",{parentName:"p"},"MAXRECVMESSAGE"),". Once assigned to a thread, the message gets dispatched according to the earlier section."),Object(a.b)("p",null,"Equivalently, before an outgoing message is written out to a socket, it is first inserted into ",Object(a.b)("inlineCode",{parentName:"p"},"P2PComm::m_sendQueue"),", whose maximum size is controlled by ",Object(a.b)("inlineCode",{parentName:"p"},"SENDQUEUE_SIZE"),". Any further outgoing messages are also dropped once the queue is full. A dedicated thread launched during startup also manages dequeueing of messages and sending them to ",Object(a.b)("inlineCode",{parentName:"p"},"Zilliqa::m_SendPool"),", which is also limited by ",Object(a.b)("inlineCode",{parentName:"p"},"MAXSENDMESSAGE"),". One assigned to a thread, the message gets sent out according to the ",Object(a.b)("inlineCode",{parentName:"p"},"P2PComm::SendJob")," settings for the message."))}l.isMDXComponent=!0},280:function(e,t,n){"use strict";n.d(t,"a",(function(){return d})),n.d(t,"b",(function(){return b}));var r=n(0),o=n.n(r);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function s(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?s(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function c(e,t){if(null==e)return{};var n,r,o=function(e,t){if(null==e)return{};var n,r,o={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var u=o.a.createContext({}),l=function(e){var t=o.a.useContext(u),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},d=function(e){var t=l(e.components);return o.a.createElement(u.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return o.a.createElement(o.a.Fragment,{},t)}},m=o.a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,a=e.originalType,s=e.parentName,u=c(e,["components","mdxType","originalType","parentName"]),d=l(n),m=r,b=d["".concat(s,".").concat(m)]||d[m]||p[m]||a;return n?o.a.createElement(b,i(i({ref:t},u),{},{components:n})):o.a.createElement(b,i({ref:t},u))}));function b(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var a=n.length,s=new Array(a);s[0]=m;var i={};for(var c in t)hasOwnProperty.call(t,c)&&(i[c]=t[c]);i.originalType=e,i.mdxType="string"==typeof e?e:r,s[1]=i;for(var u=2;u<a;u++)s[u]=n[u];return o.a.createElement.apply(null,s)}return o.a.createElement.apply(null,n)}m.displayName="MDXCreateElement"}}]);