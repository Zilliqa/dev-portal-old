(window.webpackJsonp=window.webpackJsonp||[]).push([[59],{163:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return a})),n.d(t,"metadata",(function(){return s})),n.d(t,"rightToc",(function(){return l})),n.d(t,"default",(function(){return d}));var i=n(2),o=n(6),r=(n(0),n(256)),a={id:"core-pow",title:"PoW Algorithm",keywords:["core","por","proof","work","algorithm"],description:"Core protocol design - PoW algorithm."},s={id:"contributors/core-pow",isDocsHomePage:!1,title:"PoW Algorithm",description:"Core protocol design - PoW algorithm.",source:"@site/docs/contributors/core-pow.md",permalink:"/docs/contributors/core-pow",editUrl:"https://github.com/Zilliqa/dev-portal/tree/master/docs/contributors/core-pow.md",sidebar:"ContributorsSidebar",previous:{title:"Multipliers",permalink:"/docs/contributors/core-multipliers"},next:{title:"Difficulty Adjustment",permalink:"/docs/contributors/core-difficulty-adjustment"}},l=[{value:"Proof-of-Work",id:"proof-of-work",children:[]},{value:"Why PoW is Needed",id:"why-pow-is-needed",children:[]},{value:"Ethash Algorithm",id:"ethash-algorithm",children:[]},{value:"PoW Modes",id:"pow-modes",children:[{value:"Light Dataset Mine",id:"light-dataset-mine",children:[]},{value:"Full Dataset Mine",id:"full-dataset-mine",children:[]},{value:"GPU Mine",id:"gpu-mine",children:[]},{value:"Getwork Server Mine",id:"getwork-server-mine",children:[]},{value:"Remote Mine",id:"remote-mine",children:[]}]},{value:"References",id:"references",children:[]}],c={rightToc:l};function d(e){var t=e.components,n=Object(o.a)(e,["components"]);return Object(r.b)("wrapper",Object(i.a)({},c,n,{components:t,mdxType:"MDXLayout"}),Object(r.b)("hr",null),Object(r.b)("h2",{id:"proof-of-work"},"Proof-of-Work"),Object(r.b)("p",null,"Proof-of-Work, or PoW, is the original consensus algorithm in a blockchain network. In other blockchains (e.g., Bitcoin and Ethereum), this algorithm is used to confirm transactions and produce new blocks in the chain. With PoW, miners compete against each other to complete transactions on the network and get rewarded."),Object(r.b)("p",null,"In Zilliqa, PoW is used as a threshold the shard nodes need to meet to join the network. Afterwards, the nodes can start to sign transactions and get rewarded. So, in Zilliqa, completion of PoW doesn't actually mean the node can already get rewarded."),Object(r.b)("h2",{id:"why-pow-is-needed"},"Why PoW is Needed"),Object(r.b)("p",null,"The main benefits of using PoW are the anti-DoS attacks defense and low impact of stake on mining possibilities."),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"Defense from DoS attacks"),".  PoW imposes some limits on actions in the network. Firstly, it needs a lot of effort to be executed. Efficient attacks require a lot of computational power and a lot of time to do these calculations. Therefore, the attack is possible but also kind of useless since the costs are too high."),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"Mining possibilities"),". It doesn\u2019t matter how much money you have in your wallet. What matters is to have large computational power to solve the puzzles and form new blocks. Thus, the holders of huge amounts of money are not in charge of making decisions for the entire network."),Object(r.b)("h2",{id:"ethash-algorithm"},"Ethash Algorithm"),Object(r.b)("p",null,"The Zilliqa blockchain uses the Ethash algorithm, which is originally from Ethereum."),Object(r.b)("p",null,"Ethash is the proof-of-work function in Ethereum-based blockchain currencies. It uses Keccak, a hash function eventually standardized to SHA-3 (these two are different, and should not be confused)."),Object(r.b)("p",null,"Since version 1.0, Ethash has been designed to be ASIC-resistant via memory-hardness (i.e., harder to implement in special ASIC chips) and easily verifiable. It also uses a slightly modified version of earlier Dagger and Hashimoto hashes to remove computational overhead. Previously referred to as Dagger-Hashimoto, the Ethash function has evolved over time. Ethash uses an initial 1GB dataset known as the Ethash DAG and a 16MB cache for light clients to hold. These are regenerated every 30,000 blocks (known as an epoch). Miners grab slices of the DAG to generate mix-hashes using transaction and receipt data, along with a cryptographic nonce to generate a hash below a dynamic target difficulty."),Object(r.b)("h2",{id:"pow-modes"},"PoW Modes"),Object(r.b)("p",null,"Zilliqa supports 5 modes of PoW. Some are suitable for local or small-scale testing, while other modes are intended for Mainnet mining."),Object(r.b)("h3",{id:"light-dataset-mine"},"Light Dataset Mine"),Object(r.b)("p",null,"This is the default mining mode if you don't change any parameters in ",Object(r.b)("inlineCode",{parentName:"p"},"constants.xml"),". It uses CPU to do PoW. It will generate the DAG data dynamically and doesn't store it in memory; hence, it is the slowest method, but it also doesn't require the 1GB RAM. It is suitable for local testing or small-scale cloud testing. It is not suitable for Mainnet mining."),Object(r.b)("h3",{id:"full-dataset-mine"},"Full Dataset Mine"),Object(r.b)("p",null,"This mode will be enabled if ",Object(r.b)("inlineCode",{parentName:"p"},"FULL_DATASET_MINE")," is set to ",Object(r.b)("inlineCode",{parentName:"p"},"true")," in ",Object(r.b)("inlineCode",{parentName:"p"},"constants.xml"),". It uses CPU to do PoW. It is similar to the light dataset mine mode - the DAG is generated dynamically. However, after the DAG is generated, it is saved in memory. So, next time the same DAG needs to be used, it will be read out directly from memory. This method is faster than the light dataset mine mode, but it requires 1GB RAM on the hardware. It is suitable for local testing or small-scale cloud testing. It is not suitable for Mainnet mining."),Object(r.b)("h3",{id:"gpu-mine"},"GPU Mine"),Object(r.b)("p",null,"This mode will be enabled if either ",Object(r.b)("inlineCode",{parentName:"p"},"CUDA_GPU_MINE")," or ",Object(r.b)("inlineCode",{parentName:"p"},"OPENCL_GPU_MINE")," is set to ",Object(r.b)("inlineCode",{parentName:"p"},"true")," in ",Object(r.b)("inlineCode",{parentName:"p"},"constants.xml"),". It uses GPU to do PoW. There are more parameters available for this mode in the ",Object(r.b)("inlineCode",{parentName:"p"},"GPU")," section in ",Object(r.b)("inlineCode",{parentName:"p"},"constants.xml"),". This mode uses GPU to generate the DAG, and the DAG is saved in GPU RAM. It requires that the GPU have at least 1GB RAM. Because a GPU has thousands of cores, the mining speed can be much faster than CPU mining. It is suitable for Mainnet mining, but only during the bootstrap phase; now the Mainnet difficulty is too high for a single machine to finish PoW within the required time. Hence it is now suitable only for test purposes."),Object(r.b)("h3",{id:"getwork-server-mine"},"Getwork Server Mine"),Object(r.b)("p",null,"This mode will be enabled if ",Object(r.b)("inlineCode",{parentName:"p"},"GETWORK_SERVER_MINE")," is set to ",Object(r.b)("inlineCode",{parentName:"p"},"true")," in ",Object(r.b)("inlineCode",{parentName:"p"},"constants.xml"),". The Zilliqa node will be used as a mining server, and other GPU machines can get work from this server and submit the result if the node's GPU machine can find a result. This mode can combine the hash power of multiple GPU machines together to finish a high-difficulty PoW job. But this setup is not easy to maintain if there are multiple Zilliqa nodes using this mode."),Object(r.b)("h3",{id:"remote-mine"},"Remote Mine"),Object(r.b)("p",null,"This mode will be enabled if ",Object(r.b)("inlineCode",{parentName:"p"},"REMOTE_MINE")," is set to ",Object(r.b)("inlineCode",{parentName:"p"},"true")," in ",Object(r.b)("inlineCode",{parentName:"p"},"constants.xml"),". Also, ",Object(r.b)("inlineCode",{parentName:"p"},"MINING_PROXY_URL")," needs to be set to the address of the mining proxy. In this mode, multiple Zilliqa nodes can send PoW work requests to the mining proxy, and the mining proxy dispatches the work packages to multiple mining machines. If a mining machine finds a result, it sends it to the mining proxy, and the mining proxy in turn sends it to the Zilliqa node. This mode can support multiple Zilliqa nodes and mining machines, but it requires running a mining proxy server separately."),Object(r.b)("h2",{id:"references"},"References"),Object(r.b)("ol",null,Object(r.b)("li",{parentName:"ol"},Object(r.b)("a",Object(i.a)({parentName:"li"},{href:"https://en.wikipedia.org/wiki/Ethash"}),"Ethash")),Object(r.b)("li",{parentName:"ol"},Object(r.b)("a",Object(i.a)({parentName:"li"},{href:"https://github.com/DurianStallSingapore/Zilliqa-Mining-Proxy"}),"Mining Proxy"))))}d.isMDXComponent=!0},256:function(e,t,n){"use strict";n.d(t,"a",(function(){return h})),n.d(t,"b",(function(){return p}));var i=n(0),o=n.n(i);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,i,o=function(e,t){if(null==e)return{};var n,i,o={},r=Object.keys(e);for(i=0;i<r.length;i++)n=r[i],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(i=0;i<r.length;i++)n=r[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var c=o.a.createContext({}),d=function(e){var t=o.a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},h=function(e){var t=d(e.components);return o.a.createElement(c.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return o.a.createElement(o.a.Fragment,{},t)}},u=o.a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,a=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),h=d(n),u=i,p=h["".concat(a,".").concat(u)]||h[u]||m[u]||r;return n?o.a.createElement(p,s(s({ref:t},c),{},{components:n})):o.a.createElement(p,s({ref:t},c))}));function p(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,a=new Array(r);a[0]=u;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:i,a[1]=s;for(var c=2;c<r;c++)a[c]=n[c];return o.a.createElement.apply(null,a)}return o.a.createElement.apply(null,n)}u.displayName="MDXCreateElement"}}]);